// Generated by CoffeeScript 1.12.4
(function() {
  'use strict';
  TopViewer.Volume = (function() {
    function Volume(options) {
      var a, a_old, addLine, connectivity, cornerIndexArray, cornerIndexAttribute, globalLineVertexIndex, height, i, index, isosurfaceMaterial, isosurfacesGeometry, isosurfacesMesh, j, k, ks, l, linesCount, localLineVertexIndex, localLinesCount, localTetraCount, loopVertexIndex, m, n, o, p, q, r, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, setVertexIndexCoordinates, splitAt, tetraAccessArray, tetraAccessAttribute, tetraCount, tetraHeight, tetraSplits, tetraTextureArray_X, tetraTextureArray_Y, tetraWidth, vertexIndexArray, vertexIndexAttribute, width, wireSplits, wireframeGeometry, wireframeMesh, ws;
      this.options = options;
      height = this.options.model.basePositionsTexture.image.height;
      width = this.options.model.basePositionsTexture.image.width;
      debugger;
      connectivity = [];
      linesCount = 0;
      setVertexIndexCoordinates = function(attribute, i, index, width, height) {
        attribute.setX(i, index % width / width);
        return attribute.setY(i, Math.floor(index / width) / height);
      };
      addLine = function(a, b) {
        var ref;
        if (a > b) {
          ref = [b, a], a = ref[0], b = ref[1];
        }
        if (connectivity[a] == null) {
          connectivity[a] = [];
        }
        if (connectivity[a].indexOf(b) === -1) {
          connectivity[a].push(b);
          return linesCount++;
        }
      };
      for (i = j = 0, ref = this.options.elements.length / 4; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        addLine(this.options.elements[i * 4], this.options.elements[i * 4 + 1]);
        addLine(this.options.elements[i * 4 + 1], this.options.elements[i * 4 + 2]);
        addLine(this.options.elements[i * 4 + 2], this.options.elements[i * 4]);
        addLine(this.options.elements[i * 4], this.options.elements[i * 4 + 3]);
        addLine(this.options.elements[i * 4 + 1], this.options.elements[i * 4 + 3]);
        addLine(this.options.elements[i * 4 + 2], this.options.elements[i * 4 + 3]);
      }
      this.wireframeMeshes = [];
      splitAt = 500000000;
      globalLineVertexIndex = 0;
      wireSplits = Math.ceil(linesCount / splitAt);
      a_old = 0;
      for (ws = k = 0, ref1 = wireSplits; 0 <= ref1 ? k < ref1 : k > ref1; ws = 0 <= ref1 ? ++k : --k) {
        if (ws === wireSplits - 1) {
          localLinesCount = linesCount - ws * splitAt;
        } else {
          localLinesCount = splitAt;
        }
        wireframeGeometry = new THREE.BufferGeometry();
        wireframeMesh = new THREE.LineSegments(wireframeGeometry, this.options.model.volumeWireframeMaterial);
        this.wireframeMeshes.push(wireframeMesh);
        debugger;
        vertexIndexArray = new Float32Array(localLinesCount * 4);
        vertexIndexAttribute = new THREE.BufferAttribute(vertexIndexArray, 2);
        localLineVertexIndex = 0;
        loopVertexIndex = 0;
        for (a = l = ref2 = a_old, ref3 = connectivity.length; ref2 <= ref3 ? l < ref3 : l > ref3; a = ref2 <= ref3 ? ++l : --l) {
          if (!connectivity[a]) {
            continue;
          }
          for (i = m = 0, ref4 = connectivity[a].length; 0 <= ref4 ? m < ref4 : m > ref4; i = 0 <= ref4 ? ++m : --m) {
            if ((loopVertexIndex >= globalLineVertexIndex - 1) && (localLineVertexIndex <= localLinesCount * 2)) {
              setVertexIndexCoordinates(vertexIndexAttribute, localLineVertexIndex, parseInt(a), width, height);
              setVertexIndexCoordinates(vertexIndexAttribute, localLineVertexIndex + 1, connectivity[a][i], width, height);
              globalLineVertexIndex += 2;
              localLineVertexIndex += 2;
              loopVertexIndex += 2;
            } else {
              loopVertexIndex += 2;
            }
          }
        }
        a_old = a - 1;
        wireframeGeometry.addAttribute("vertexIndex", vertexIndexAttribute);
        wireframeMesh.material.uniforms.bufferTextureHeight.value = height;
        wireframeMesh.material.uniforms.bufferTextureWidth.value = width;
        wireframeGeometry.setDrawRange(0, localLineVertexIndex);
        debugger;
      }
      this.isosurfaceMeshes = [];
      tetraCount = this.options.elements.length / 4;
      splitAt = 20000000;
      tetraSplits = Math.ceil(tetraCount / splitAt);
      for (ks = n = 0, ref5 = tetraSplits; 0 <= ref5 ? n < ref5 : n > ref5; ks = 0 <= ref5 ? ++n : --n) {
        if (ks === tetraSplits - 1) {
          localTetraCount = tetraCount - ks * splitAt;
        } else {
          localTetraCount = splitAt;
        }
        log(localTetraCount);
        isosurfaceMaterial = new TopViewer.IsosurfaceMaterial(this);
        this.options.model.isosurfaceMaterials.push(isosurfaceMaterial);
        isosurfacesGeometry = new THREE.BufferGeometry();
        isosurfacesMesh = new THREE.Mesh(isosurfacesGeometry, isosurfaceMaterial);
        isosurfacesMesh.receiveShadows = true;
        this.isosurfaceMeshes.push(isosurfacesMesh);
        debugger;
        tetraHeight = 1;
        tetraWidth = this.options.model.maxTextureWidth;
        while (localTetraCount > tetraWidth * tetraHeight) {
          tetraHeight *= 2;
        }
        tetraTextureArray_X = new Float32Array(tetraWidth * tetraHeight * 4);
        for (i = o = 0, ref6 = localTetraCount * 4; 0 <= ref6 ? o < ref6 : o > ref6; i = 0 <= ref6 ? ++o : --o) {
          tetraTextureArray_X[i] = (this.options.elements[i + ks * splitAt * 4] % width) / width;
        }
        tetraTextureArray_Y = new Float32Array(tetraWidth * tetraHeight * 4);
        for (i = p = 0, ref7 = localTetraCount * 4; 0 <= ref7 ? p < ref7 : p > ref7; i = 0 <= ref7 ? ++p : --p) {
          tetraTextureArray_Y[i] = Math.floor(this.options.elements[i + ks * splitAt * 4] / width) / height;
        }
        tetraAccessArray = new Float32Array(localTetraCount * 12);
        tetraAccessAttribute = new THREE.BufferAttribute(tetraAccessArray, 2);
        cornerIndexArray = new Float32Array(localTetraCount * 6);
        cornerIndexAttribute = new THREE.BufferAttribute(cornerIndexArray, 1);
        for (i = q = 0, ref8 = tetraAccessArray.length / 2; 0 <= ref8 ? q < ref8 : q > ref8; i = 0 <= ref8 ? ++q : --q) {
          index = Math.floor(i / 6.0);
          setVertexIndexCoordinates(tetraAccessAttribute, i, index, tetraWidth, tetraHeight);
          cornerIndexArray[i] = (i % 6.0) * 0.1;
        }
        isosurfacesGeometry.addAttribute("tetraAccess", tetraAccessAttribute);
        isosurfacesGeometry.addAttribute("cornerIndex", cornerIndexAttribute);
        isosurfacesMesh.material.uniforms.tetraTextureHeight.value = tetraHeight;
        isosurfacesMesh.material.uniforms.tetraTextureWidth.value = tetraWidth;
        isosurfacesMesh.material.uniforms.bufferTextureHeight.value = height;
        isosurfacesMesh.material.uniforms.bufferTextureWidth.value = width;
        isosurfacesMesh.material.uniforms.tetraTextureX.value = new THREE.DataTexture(tetraTextureArray_X, tetraWidth, tetraHeight, THREE.RGBAFormat, THREE.FloatType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
        isosurfacesMesh.material.uniforms.tetraTextureY.value = new THREE.DataTexture(tetraTextureArray_Y, tetraWidth, tetraHeight, THREE.RGBAFormat, THREE.FloatType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
        isosurfacesMesh.material.uniforms.tetraTextureX.value.needsUpdate = true;
        isosurfacesMesh.material.uniforms.tetraTextureY.value.needsUpdate = true;
        isosurfacesMesh.material.uniforms.basePositionsTexture.value = this.options.model.basePositionsTexture;
        isosurfacesGeometry.setDrawRange(0, localTetraCount * 6);
      }
      debugger;
      this._updateGeometry();
      for (i = r = 0, ref9 = this.isosurfaceMeshes.length; 0 <= ref9 ? r < ref9 : r > ref9; i = 0 <= ref9 ? ++r : --r) {
        this.options.model.add(this.isosurfaceMeshes[i]);
      }
      for (i = s = 0, ref10 = this.wireframeMeshes.length; 0 <= ref10 ? s < ref10 : s > ref10; i = 0 <= ref10 ? ++s : --s) {
        this.options.model.add(this.wireframeMeshes[i]);
      }
      this.options.engine.renderingControls.addVolume(this.options.name, this);
    }

    Volume.prototype._updateGeometry = function() {
      var i, j, k, ref, ref1, results;
      for (i = j = 0, ref = this.wireframeMeshes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this._updateBounds(this.wireframeMeshes[i], this.options.model);
      }
      results = [];
      for (i = k = 0, ref1 = this.isosurfaceMeshes.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        results.push(this._updateBounds(this.isosurfaceMeshes[i], this.options.model));
      }
      return results;
    };

    Volume.prototype._updateBounds = function(mesh, model) {
      mesh.geometry.boundingBox = model.boundingBox;
      return mesh.geometry.boundingSphere = model.boundingSphere;
    };

    Volume.prototype.showFrame = function() {
      var i, j, k, l, m, ref, ref1, ref2, ref3, results;
      if (!this.renderingControls) {
        for (i = j = 0, ref = this.wireframeMeshes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.wireframeMeshes[i].visible = false;
        }
        for (i = k = 0, ref1 = this.isosurfaceMeshes.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          this.isosurfaceMeshes[i].visible = false;
        }
        return;
      }
      for (i = l = 0, ref2 = this.wireframeMeshes.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        this.wireframeMeshes[i].visible = this.renderingControls.showWireframeControl.value();
      }
      results = [];
      for (i = m = 0, ref3 = this.isosurfaceMeshes.length; 0 <= ref3 ? m < ref3 : m > ref3; i = 0 <= ref3 ? ++m : --m) {
        results.push(this.isosurfaceMeshes[i].visible = this.renderingControls.showIsosurfacesControl.value());
      }
      return results;
    };

    return Volume;

  })();

}).call(this);

//# sourceMappingURL=volume.js.map
